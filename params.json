{"name":"Hecuba","tagline":"The abstraction over all cassandra clients (like Hector and Astyanax)","body":"Hecuba\r\n======\r\n\r\nThere are few widely used Apache Cassandra clients and Hecuba is the abstraction over those clients so that you can switch between those easily.\r\n\r\nHecuba is currently in use in Wize Commerce and is being actively developed. \r\n\r\nWhy Hecuba\r\n==========\r\nIn greek mythology [Hecuba][http://en.wikipedia.org/wiki/Hecuba] is the mother of [Hector][http://en.wikipedia.org/wiki/Hector] and [Cassandra][http://en.wikipedia.org/wiki/Cassandra] and grand mother of [Asytanax][http://en.wikipedia.org/wiki/Astyanax]. Whereas in NoSQL world Cassandra is a NoSQL storage, Hector and Astyanax are clients (Astyanax had initially spawned off of Hector) and Hecuba is the abstraction over Astyanax and Hector.    \r\n\r\nFeatures\r\n========\r\n\r\n- Hecuba supports all the regular methods to interact with Cassandra including gets, multigets, row and column slices, writes and deletes. \r\n- Hecuba can be used to maintain your own secondary index without relying on Cassandra's implementation of secondary indexes. The main difference here is that Cassandra implementation tries to maintain the locality of the secondary indexes with the knowledge of the topology whereas hecuba implementation consider secondary index as another independent column family with pointers to the main table. \r\n\r\nUser Guide\r\n==========\r\n\r\nUsage\r\n-----\r\n\r\n### Initialization\r\n\r\n```java\r\n    CassandraParamsBean parameters = new CassandraParamsBean();\r\n    parameters.setClusterName(\"Cluster Name\");  // set the name of the cluster. You can find the name of the cluster from cassandra.yaml file\r\n    parameters.setLocationURLs(\"node1:node2:node3\"); // list of nodes in the cluster separated by ':'\r\n    parameters.setThriftPorts(\"9180\"); // port the above cassandra nodes listening to for client requests\r\n    parameters.setKeyspace(\"MyKeyspace\"); // the keyspace you need to connect to\r\n    parameters.setCf(\"MyColumnFamily\"); // the column family you need to connect to\r\n    parameters.setKeyType(\"Long\") // the java type of the keys of the cassandra cluster. This can be either Long or String.\r\n    \r\n    // initialize a client based on Astyanax\r\n    //HecubaClientManager<String> cassandraManager = new AstyanaxBasedHecubaClientManager<String>(parameters, com.netflix.astyanax.serializer.StringSerializer.get());\r\n\r\n    // or initialize a client based on Hector\r\n    HecubaClientManager<String> cassandraManager = new HectorBasedHecubaClientManager<String>(parameters, me.prettyprint.cassandra.serializers.StringSerializer.get(), true);\r\n```\r\n\r\n### Write data \r\n\r\n```java\r\n   // update a single column. Similarly, you can invoke updateDouble, updateLong, etc\r\n   cassandraManager.updateString(key, columnName, columnValue);\r\n\r\n   // update a single column with timestamp and ttl. By default each of these values are set to -1 so that the underlying client implementations will provide timestamps and set the TTL to never expire.\r\n   cassandraManager.updateString(key, columnName, columnValue, timestamp, ttl);\r\n\r\n   // update a whole row at once by passing a map of column names and values. Values can be strings, longs, booleans or Dates. Everything else has to be implement toString otherwise. \r\n   Map<String, Object> columns = ...\r\n   cassandraManager.updateRow(key, columns);\r\n\r\n   // update a whole row with ttls and timestamps\r\n    Map<String, Long> timestamps = ...\r\n\tMap<String, Integer> ttls = ...\r\n\tcassandraManager.updateRow(key, columns, timestamps, ttls);\r\n```\r\n\r\n### Read data\r\n\r\n```java\r\n\r\n    // read all columns of a single row (single get)\r\n    CassandraResultSet<K, String> columnValues = cassandraManager.readAllColumns(objectId);\r\n\r\n    // read all columns of multiple rows (multi get)\r\n    Set<Long> keysOfObjectsToBeRetrieved = new HashSet<Long>();\r\n    CassandraResultSet<K, String> columnValues = cassandraManager.readAllColumns(keysOfObjectsToBeRetrieved);\r\n\r\n    // read single column as string. \r\n    String stringColumnValue = cassandraManager.readString(key, stringColumnName);\r\n\r\n    // read single column as double\r\n    Double doubleValue = cassandraManager.readDouble(key, doubleColumnValue);\r\n\r\n    // you can even pass in the default value so that this method returns it if there is no value found for that column inside Cassandra. You can similarly use readBoolean, readInteger methods. \r\n    Double doubleValue = cassandraManager.readDouble(key, doubleColumnValue, defaultDoubleValue);\r\n\r\n    // read only a given set of columns for an object.\r\n    List<String> columnsNamesToBeRetrieved = ...\r\n    CassandraResultSet<K, String> columns = cassandraManager.readColumns(key, columnsNamesToBeRetrieved); \r\n\r\n    // similarly you can pass in a set of keys if you want to read columns of multiple keys.\r\n```    \r\n\r\nCurrent Limitations\r\n===================\r\n\r\n- Hecuba assumes all column names and values are strings. \r\n\r\n\r\n \r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}